// Types.

/// A Rust module.
inc_id Module: u32 {}
/// An item such a function or a constant.
inc_id Item: u32 {}
/// A scope.
inc_id Scope: u32 {}
/// A function call.
inc_id FunctionCall: u32 {}
/// A span (an interned location in the program with additional information
/// such as macro expansion).
inc_id Span: u64 {
    /// A dummy span that is used as a call site span for a span that is a root span.
    ROOT_PARENT_SPAN = 0u64,
}
/// A type.
inc_id Type: u64 {}
/// An ADT field.
inc_id Field: u64 {}
/// An operand.
inc_id Operand: u64 {}
/// A basic block.
inc_id BasicBlock: u64 {
    /// A value to encode `None` of `Option<BasicBlock>`.
    NO_BLOCK = 0u64,
}
/// A statement.
inc_id Statement: u64 {}

// thir types
/// A THIR-level block
inc_id ThirBlock: u64 {
    /// A value to encode `None` of `Option<ThirBlock>`.
    NO_THIR_BLOCK = 0u64,
}
inc_id ThirExpr: u64 {
    /// A value to encode `None` of `Option<ThirExpr>`.
    NO_THIR_EXPR = 0u64,
}
inc_id ThirPat: u64 {
    /// A value to encode `None` of `Option<ThirPat>`.
    NO_THIR_PAT = 0u64,
}
inc_id ThirStmt: u64 {
    /// A value to encode `None` of `Option<ThirStmt>`.
    NO_THIR_STMT = 0u64,
}

/// The hash of the crate as reported by the compiler.
custom_id CrateHash: u128 {
    impl From<u128> for CrateHash {
        fn from(value: u128) -> Self {
            Self(value)
        }
    }

    impl std::fmt::LowerHex for CrateHash {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(f, "{:x}", self.0)
        }
    }
}

custom_id DefPathHash: (u64, u64) {
    impl From<(u64, u64)> for DefPathHash {
        fn from(value: (u64, u64)) -> Self {
            Self(value)
        }
    }
    impl std::fmt::LowerHex for DefPathHash {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(f, "{:x}{:x}", (self.0).0, (self.0).1)
        }
    }
}

custom_id AdtVariantIndex: u16 {}
custom_id TupleFieldIndex: u16 {}
custom_id FnParamIndex: u16 {}
custom_id OperandIndex: u16 {}
custom_id StatementIndex: u16 {}
custom_id CallArgIndex: u16 {}
custom_id ThirCallArgIndex: u16 {}
custom_id MatchArmIdx: u16 {}
custom_id FieldIndex: u16 {}

/// Mutability of an item. Having a const variant allows merging statics with constants.
enum Mutability {
    Mutable,
    Immutable,
    Const,
    #[default]
    Unknown,
}

/// Constness of an implementation.
enum Constness {
    Const,
    NotConst,
    #[default]
    Unknown,
}

// /// The visibility of an item.
// enum Visibility {
//     /// The item is declared as public (`pub`).
//     Public,
//     /// The item is declared as public within the crate (`pub(crate)`).
//     Crate,
//     /// The item is declared as public for some modules (`pub(in foo:bar)`).
//     Restricted,
//     /// The item is declared as private (default visibility).
//     Private,
//     /// Failed to obtain visibility information from the compiler.
//     #[default]
//     Unknown,
// }

/// The visibility of an item used in `ty`.
enum TyVisibility {
    /// Visible everywhere (including in other crates).
    Public,
    /// Visible only in the given crate-local module.
    Restricted,
    /// Not visible anywhere in the local crate. This is the visibility
    /// of private external items.
    Invisible,
    /// Failed to obtain visibility information from the compiler.
    #[default]
    Unknown,
}

/// The safety of an item.
enum Safety {
    Unsafe,
    Safe,
    /// Failed to obtain unsafety information from the compiler.
    ///
    /// TODO: For closures we could check if that closure is declared inside an unsafe block.
    #[default]
    Unknown,
}

/// The polarity of an implementation.
enum ImplPolarity {
    /// `impl Trait for Type`
    Positive,
    /// `impl !Trait for Type`
    Negative,
    /// Failed to obtain polarity information from the compiler.
    #[default]
    Unknown,
}

/// The safety of a scope.
enum ScopeSafety {
    /// The scope is safe.
    Safe,
    /// The scope is unsafe because of a PushUnsafeBlock.
    BuiltinUnsafe,
    /// The scope is unsafe because it is inside an unsafe function.
    FnUnsafe,
    /// The scope is unsafe because it is inside an unsafe block.
    ExplicitUnsafe,
    /// Failed to obtain the safety information from the compiler.
    #[default]
    Unknown,
}

/// The kind of a user defined type.
enum AdtKind {
    Struct,
    Union,
    Enum,
    /// Failed to obtain the kind from the compiler.
    #[default]
    Unknown,
}

/// A primitive type kind.
enum TyPrimitive {
    /// Failed to obtain the kind from the compiler.
    #[default]
    Unknown,
    Bool,
    Char,
    Isize,
    I8,
    I16,
    I32,
    I64,
    I128,
    Usize,
    U8,
    U16,
    U32,
    U64,
    U128,
    F16,
    F32,
    F64,
    F128,
    Str,
    Never,
}

/// Kind of the type definiton.
enum TyDefKind {
    /// Failed to obtain the kind from the compiler.
    #[default]
    Unknown,
    TyAlias,
    OpaqueTy,
    Enum,
    Struct,
    Union,
}

/// Defaultness of the item associated with a trait.
enum Defaultness {
    /// Failed to obtain the kind from the compiler.
    #[default]
    Unknown,
    DefaultWithValue,
    DefaultNoValue,
    Final,
}

/// The kind of a mir operand.
enum OperandKind {
    /// Failed to obtain the kind from the compiler.
    #[default]
    Unknown,
    Copy,
    Move,
    Constant,
}

/// The kind of a mir aggregate statement.
enum AggregateKind {
    /// Failed to obtain the kind from the compiler.
    #[default]
    Unknown,
    Array,
    Tuple,
    Adt,
    Closure,
    Coroutine,
    CoroutineClosure,
    RawPtr,
}

/// The kind of a cast operation.
enum CastKind {
    /// Failed to obtain the kind from the compiler.
    #[default]
    Unknown,
    Misc,
    ReifyFnPointer,
    UnsafeFnPointer,
    UnsafeClosureFnPointer,
    SafeClosureFnPointer,
    MutToConstPointer,
    ArrayToPointer,
    UnsizePointer,
    PointerExposeProvenance,
    PointerWithExposedProvenance,
    DynStar,
    IntToInt,
    FloatToInt,
    IntToFloat,
    FloatToFloat,
    PtrToPtr,
    FnPtrToPtr,
    Transmute,
}

/// The kind of a MIR borrow statement.
enum BorrowKind {
    /// Failed to obtain the kind from the compiler.
    #[default]
    Unknown,
    Shared,
    Shallow,
    Deep,
    ClosureCapture,
    Mut,
    MutTwoPhase,
}

/// The kind of a MIR basic block.
enum BasicBlockKind {
    /// A regular basic block.
    #[default]
    Regular,
    /// The basic block is the CFG entry point.
    Entry,
    /// The basic block is on the unwind path.
    CleanUp,
}

/// rustc_span::hygiene::ExpnKind
enum SpanExpansionKind {
    /// Failed to obtain the kind from the compiler.
    #[default]
    Unknown,
    /// No expansion.
    Root,
    /// A bang macro `foo!()`.
    MacroBang,
    /// An attribute macro `#[foo]`.
    MacroAttr,
    /// A derive macro `#[derive(Foo)]`.
    MacroDerive,
    /// Transform done by the compiler on the AST.
    AstPassStdImports,
    /// Transform done by the compiler on the AST.
    AstPassTestHarness,
    /// Transform done by the compiler on the AST.
    AstPassProcMacroHarness,
    /// Desugaring done by the compiler during HIR lowering.
    DesugaringCondTemporary,
    /// Desugaring done by the compiler during HIR lowering.
    DesugaringQuestionMark,
    /// Desugaring done by the compiler during HIR lowering.
    DesugaringTryBlock,
    /// Desugaring done by the compiler during HIR lowering.
    /// Desugaring of an `impl Trait` in return type position to an
    /// `type Foo = impl Trait;` and replacing the `impl Trait` with
    /// `Foo`.
    DesugaringOpaqueTy,
    /// Desugaring done by the compiler during HIR lowering.
    DesugaringAsync,
    /// Desugaring done by the compiler during HIR lowering.
    DesugaringAwait,
    /// Desugaring done by the compiler during HIR lowering.
    DesugaringForLoop,
    /// Desugaring done by the compiler during HIR lowering.
    DesugaringWhileLoop,
    /// Desugaring done by the compiler during HIR lowering.
    DesugaringLetElse,
    /// Desugaring done by the compiler during HIR lowering.
    DesugaringYeetExpr,
    /// Desugaring done by the compiler during HIR lowering.
    DesugaringBoundModifier,
    /// Inlined MIR.
    Inlined,
}

/// rustc_hir::UnsafeSource
enum BlockCheckMode {
    #[default]
    DefaultBlock,
    UnsafeBlockCompilerGenerated,
    UnsafeBlockUserProvided,
    PushUnsafeBlockCompilerGenerated,
    PushUnsafeBlockUserProvided,
    PopUnsafeBlockCompilerGenerated,
    PopUnsafeBlockUserProvided,
}

/// rustc_middle::mir::UnwindAction
enum UnwindAction {
    #[default]
    Unknown,
    Continue,
    Unreachable,
    Terminate,
    Cleanup,
}
/// rustc_middle::ty::adjustment::PointerCoercion
enum PointerCoercion {
    #[default]
    Unknown,
    ReifyFnPointer,
    UnsafeFnPointer,
    ClosreFnPointer,
    MutToConstPointer,
    ArrayToPointer,
    Unsize,
    DynStar,
}
/// rustc_hir::hir::MatchSource
enum MatchSource {
    #[default]
    Unknown,
    Normal,
    Postfix,
    ForLoopDesugar,
    TryDesugar,
    AwaitDesugar,
    FormatArgs,
}
/// rustc_hir::hir::Movability
enum Movability {
    #[default]
    Unknown,
    /// Encodes Option<Movability>::None
    None,
    Movable,
    Static,
}
/// rustc_ast::ast::LitKind
enum LitKind {
    #[default]
    Unknown,
    Str,
    ByteStr,
    CStr,
    Byte,
    Char,
    Int,
    Float,
    Bool,
    Err,
}

// Interning tables.

/// Interned strings.
intern strings<String as InternedString<u64>>;
/// Interned package names.
intern package_names<InternedString as Package<u32>>;
/// Interned package versions.
intern package_versions<InternedString as PackageVersion<u32>>;
/// Interned crate names.
intern crate_names<InternedString as Krate<u32>>;
/// Interned edition.
intern editions<InternedString as Edition<u8>>;
/// Interned names.
intern names<InternedString as Name<u32>>;
/// Interned relative definition paths.
intern relative_def_paths<InternedString as RelativeDefId<u32>>;
/// Interned MIRAI summary keys.
intern summary_keys<InternedString as SummaryId<u32>>;
/// Interned ABI.
intern abis<InternedString as Abi<u8>>;
/// Definition paths is a globally unique identifier of the definition.
intern def_paths<(Krate, CrateHash, RelativeDefId, DefPathHash, SummaryId) as DefPath<u64>>;
/// A crate compiled with a specific configuration.
intern builds<(Package, PackageVersion, Krate, CrateHash, Edition) as Build<u32>>;
/// Interned span locations.
intern span_file_names<InternedString as SpanFileName<u32>>;
/// Interned configuration keys such as `feature`.
intern crate_cfg_keys<InternedString as CrateCfgKey<u16>>;
/// Interned configuration values such as `std`.
intern crate_cfg_values<InternedString as CrateCfgValue<u16>>;
/// Interned type kinds.
intern type_kinds<InternedString as TyKind<u8>>;
/// Interned statement kinds.
intern statement_kinds<InternedString as StatementKind<u8>>;
/// Interned binary operation kind.
intern binary_op_kind<InternedString as BinOp<u8>>;
/// Interned nullary operation kind.
intern nullary_op_kind<InternedString as NullOp<u8>>;
/// Interned unary operation kind.
intern unary_op_kind<InternedString as UnOp<u8>>;
/// Interned terminator kinds.
intern terminator_kinds<InternedString as TerminatorKind<u8>>;
/// Interned ThirBinaryOpKind
intern thir_binary_op_kind<InternedString as ThirBinOp<u8>>;
/// Interned ThirLogicalOpKind
intern thir_logical_op_kind<InternedString as ThirLogicalOp<u8>>;
/// Interned ThirUnaryOpKind
intern thir_unary_op_kind<InternedString as ThirUnOp<u8>>;

// Relations.

relation def_path_span(def_path: DefPath, span: Span);
relation type_description(ty: Type, description: InternedString, generics: InternedString);
/// The crate types associated with the build.
relation build_crate_types(build: Build, crate_type: InternedString);
/// The module that is the root of the AST tree.
relation root_modules(build: Build, root_module: auto Module);
/// `(parent, child)` relation between modules.
///
/// If `abi` is not `NONE`, the `child` module is foreign.
relation submodules(def_path: DefPath, parent: Module, child: auto Module, name: Name, visibility: TyVisibility, abi: Abi);
/// An item that is a function definition.
relation function_definitions(item: auto Item, def_path: DefPath, module: Module, visibility: TyVisibility, unsafety: Safety, abi: Abi, return_ty: Type);
relation function_parameter_types(function: Item, index: FnParamIndex, typ: Type);
/// Marks whether a function uses unsafe operations directly in its body.
/// Only functions marked as `unsafe` can do that.
relation function_unsafe_use(def_path: DefPath, uses_unsafe: bool);
relation function_unsafe_reasons(def_path: DefPath, index: u32, reason: InternedString);

// new relations from mir-to-thir migration
/// THIR body expressions
relation thir_bodies(item: Item, def_path: DefPath, body: auto ThirBlock);
/// THIR-level block information
relation thir_blocks(parent: ThirBlock, block: auto ThirBlock, safety: ScopeSafety, check_mode: BlockCheckMode, span: Span);

// thir stmts
relation thir_stmts(stmt: ThirStmt, block: ThirBlock, closest_unsafe_block: ThirBlock, index: StatementIndex);
relation thir_stmts_expr(stmt: auto ThirStmt, expr: ThirExpr);
relation thir_stmts_let(stmt: auto ThirStmt, initializer: ThirExpr, else_block: ThirBlock, span: Span);

// link a block's expression to its parent block
relation thir_block_expr(block: ThirBlock, expr: ThirExpr);

// thir expressions
relation thir_exprs(expr: ThirExpr, block: ThirBlock, closest_unsafe_block: ThirBlock, ty: Type, span: Span);
relation thir_exprs_scope(expr: auto ThirExpr, inner: ThirExpr);
relation thir_exprs_box(expr: auto ThirExpr, inner: ThirExpr);
relation thir_exprs_if(expr: auto ThirExpr, cond: ThirExpr, then_expr: ThirExpr, else_expr: ThirExpr);

relation thir_exprs_call(expr: auto ThirExpr, ty: Type, fun: ThirExpr, unsafety: Safety, abi: Abi, return_ty: Type);
relation thir_exprs_call_arg(call: ThirExpr, index: ThirCallArgIndex, arg: ThirExpr);
relation thir_exprs_call_const_target(fun: ThirExpr, def_id: DefPath);
relation thir_exprs_call_const_target_desc(fun: ThirExpr, target: InternedString, function_generics: InternedString, type_generics: InternedString);
relation thir_exprs_call_const_target_self(fun: ThirExpr, typ: Type);

relation thir_exprs_deref(expr: auto ThirExpr, inner: ThirExpr);
relation thir_exprs_binary(expr: auto ThirExpr, op: ThirBinOp, lhs: ThirExpr, rhs: ThirExpr);
relation thir_exprs_logical_op(expr: auto ThirExpr, op: ThirLogicalOp, lhs: ThirExpr, rhs: ThirExpr);
relation thir_exprs_unary(expr: auto ThirExpr, op: ThirUnOp, arg: ThirExpr);
relation thir_exprs_cast(expr: auto ThirExpr, source: ThirExpr);
relation thir_exprs_use(expr: auto ThirExpr, source: ThirExpr);
relation thir_exprs_never_to_any(expr: auto ThirExpr, source: ThirExpr);
relation thir_exprs_pointer_coercion(expr: auto ThirExpr, cast: PointerCoercion, source: ThirExpr, is_from_as_cast: bool);
relation thir_exprs_loop(expr: auto ThirExpr, body: ThirExpr);
relation thir_exprs_let(expr: auto ThirExpr, inner: ThirExpr, pat: ThirPat);
relation thir_pats(pat: auto ThirPat, ty: Type, span: Span); // TODO: PatKinds?
relation thir_exprs_match(expr: auto ThirExpr, scrutinee: ThirExpr, match_source: MatchSource);
relation thir_match_arms(match_expr: ThirExpr, arm_idx: MatchArmIdx, guard: ThirExpr, body: ThirExpr);
relation thir_exprs_block(expr: auto ThirExpr, block: ThirBlock);
relation thir_exprs_assign(expr: auto ThirExpr, lhs: ThirExpr, rhs: ThirExpr);
relation thir_exprs_assign_op(expr: auto ThirExpr, op: ThirBinOp, lhs: ThirExpr, rhs: ThirExpr);
relation thir_exprs_field(expr: auto ThirExpr, lhs: ThirExpr, variant_idx: AdtVariantIndex);
relation thir_exprs_index(expr: auto ThirExpr, lhs: ThirExpr, index: ThirExpr);
relation thir_exprs_var_ref(expr: auto ThirExpr); //, id: LocalVarId); // TODO: How to handle vars?
relation thir_exprs_upvar_ref(expr: auto ThirExpr, closure_def_id: DefPath); // TODO: How to handle closures/vars?
relation thir_exprs_borrow(expr: auto ThirExpr, borrow_kind: BorrowKind, arg: ThirExpr);
relation thir_exprs_raw_borrow(expr: auto ThirExpr, mutability: Mutability, arg: ThirExpr);
relation thir_exprs_break(expr: auto ThirExpr, value: ThirExpr);
relation thir_exprs_continue(expr: auto ThirExpr);
relation thir_exprs_return(expr: auto ThirExpr, value: ThirExpr);
relation thir_exprs_become(expr: auto ThirExpr, value: ThirExpr);
relation thir_exprs_const_block(expr: auto ThirExpr, did: DefPath);
// TODO: Const block args
relation thir_exprs_repeat(expr: auto ThirExpr, value: ThirExpr);//, count: Const); // TODO: How to handle ty::Consts?
relation thir_exprs_array(expr: auto ThirExpr);
relation thir_array_elements(array_expr: ThirExpr, index: u64, element: ThirExpr);
relation thir_exprs_tuple(expr: auto ThirExpr);
relation thir_tuple_elements(tuple_expr: ThirExpr, index: TupleFieldIndex, element: ThirExpr);
relation thir_exprs_adt(expr: auto ThirExpr, base: ThirExpr/*, adt_def: AdtDef -- relation types_adt_def?*/, variant_idx: AdtVariantIndex/*, user_ty: UserTy*//**/); // TODO: How to handle UserTy
relation thir_adt_field_expr(adt: ThirExpr, field_idx: FieldIndex, expr: ThirExpr);
relation thir_exprs_place_type_ascription(expr: auto ThirExpr, source: ThirExpr, user_ty_span: Span); // TODO: Canonical user_ty
relation thir_exprs_value_type_ascription(expr: auto ThirExpr, source: ThirExpr, user_ty_span: Span); // TODO: Canonical user_ty
relation thir_exprs_closure(expr: auto ThirExpr, closure_id: DefPath, movability: Movability);
relation thir_closure_upvars(closure_expr: ThirExpr, index: u32, upvar: ThirExpr);
relation thir_exprs_literal(expr: auto ThirExpr, lit: LitKind, neg: bool);
relation thir_exprs_non_hir_literal(expr: auto ThirExpr, scalar: u128); // TODO: Canonical user_ty, ScalarInt as u128 ok?
relation thir_exprs_zst_literal(expr: auto ThirExpr); // TODO: Canonical user_ty
relation thir_exprs_named_const(expr: auto ThirExpr, def_id: DefPath); //TODO: Canonical user_ty
// TODO: args for named const
relation thir_exprs_const_param(expr: auto ThirExpr/*, param: ParamConst*/, def_id: DefPath); // How to handle ParamConst?
relation thir_exprs_static_ref(expr: auto ThirExpr, ty: Type, def_id: DefPath); // TODO: do we need alloc_id?
relation thir_exprs_inline_asm(expr: auto ThirExpr, ); // TODO: inline_asm_expr?
relation thir_exprs_offset_of(expr: auto ThirExpr, container: Type);
// TODO: add fields for OffsetOf
relation thir_exprs_thread_local_ref(expr: auto ThirExpr, def_id: DefPath);
relation thir_exprs_yield(expr: auto ThirExpr, value: ThirExpr);


/// An item that is either a constant or a static.
relation static_definitions(def_path: DefPath, item: auto Item, module: Module, name: Name, visibility: TyVisibility, mutability: Mutability);
/// An impl item.
relation impl_definitions(def_path: DefPath, item: auto Item, module: Module, name: Name, visibility: TyVisibility, unsafety: Safety, polarity: ImplPolarity, defaultness: Defaultness, constness: Constness, typ: Type);
/// An impl item that implements a trait for a type.
relation trait_impls(item: Item, typ: Type, trait_def_path: DefPath);
/// An item that is a global assembly block.
relation global_asm_blocks(def_path: DefPath, item: auto Item, module: Module, name: Name, visibility: TyVisibility);
/// A generic item that is not included in any of the categories above.
relation items(def_path: DefPath, item: auto Item, module: Module, name: Name, visibility: TyVisibility);
/// MIR cfgs inside a specific item.
relation mir_cfgs(item: Item, body_def_path: DefPath, root_scope: auto Scope);
/// parent_scope, scope, scope's safety.
/// `explicit_unsafe_group` is a unique identifier of a unsafe block within
/// a function. If `ScopeSafety` is not `ExplicitUnsafe`, then it is 0.
relation subscopes(parent: Scope, child: auto Scope, safety: ScopeSafety, check_mode: BlockCheckMode, explicit_unsafe_group: u32, span: Span);
/// Information about spans: (span, call_site_span, expansion kind, location).
relation spans(
    span: auto Span,
    call_site_span: Span,
    expansion_kind: SpanExpansionKind,
    expansion_kind_descr: InternedString,
    file_name: SpanFileName,
    line: u16,
    col: u16,
);
/// Additional information about a span that was created by a macro expansion.
relation macro_expansions(
    span: Span,
    macro_symbol: InternedString,
    macro_definition_file_name: SpanFileName,
    line: u16,
    col: u16,
);
/// Crate `cfg!` configuration.
relation crate_cfgs(build: Build, key: CrateCfgKey, value: CrateCfgValue);
/// Crate authors.
relation crate_authors(build: Build, author: InternedString);
/// Crate keywords.
relation crate_keywords(build: Build, keyword: InternedString);
/// Crate categories.
relation crate_categories(build: Build, category: InternedString);
/// A marker that `def_path` is a type.
relation type_defs(item: auto Item, typ: Type, def_path: DefPath, name: InternedString, visibility: TyVisibility, kind: TyDefKind);
/// A fact indicating that we have a monomorphized type with id `typ`.
///
/// **Note:** the fact that `typ` refers to a monomorphized type means that
/// DefId in many cases is not a key (DefId + substitutions is a key).
relation types(typ: auto Type, kind: TyKind);
relation types_primitive(typ: Type, primitive_kind: TyPrimitive);
relation types_adt_def(typ: Type, def_path: DefPath, kind: AdtKind, c_repr: bool, is_phantom: bool);
relation types_adt_variant(adt: Type, index: AdtVariantIndex, def_path: DefPath, ident: InternedString);
relation types_adt_field(field: auto Field, adt: Type, index: AdtVariantIndex, def_path: DefPath, ident: InternedString, visibility: TyVisibility, typ: Type);
/// The given field is visible only in the given module and its children.
relation types_adt_field_visible_in(field: Field, module: DefPath);
relation types_foreign(typ: Type, foreign_def_path: DefPath);
relation types_array(typ: Type, element_type: Type);
relation types_slice(typ: Type, element_type: Type);
relation types_raw_ptr(typ: Type, target_type: Type, mutability: Mutability);
relation types_ref(typ: Type, target_type: Type, mutability: Mutability);
relation types_fn_def(typ: Type, def_path: DefPath);
relation types_fn_ptr(typ: Type);
relation types_dynamic(typ: Type);
relation types_dynamic_trait(typ: Type, def_path: DefPath, is_auto: bool);
relation types_closure(typ: Type, def_path: DefPath);
relation types_generator(typ: Type, def_path: DefPath);
relation types_generator_witness(typ: Type);
relation types_tuple(typ: Type);
relation types_tuple_element(tuple_type: Type, index: TupleFieldIndex, typ: Type);
relation types_projection(typ: Type, trait_def_path: DefPath, trait_item: DefPath);
relation types_opaque(typ: Type, def_path: DefPath);
relation types_param(typ: Type, index: u32, name: InternedString);

/// Traits.
relation traits(item: auto Item, def_path: DefPath, name: InternedString, visibility: TyVisibility, is_auto: bool, is_marker: bool, unsafety: Safety);
/// Items mentioned inside the trait.
relation trait_items(trait_id: Item, def_path: DefPath, defaultness: Defaultness);

/// Basic blocks.
/// `is_cleanup` is true if the block is on the unwind path.
relation basic_blocks(block: auto BasicBlock, mir: DefPath, kind: BasicBlockKind);
/// Statements.
relation statements(stmt: Statement, block: BasicBlock, index: StatementIndex, kind: StatementKind, scope: Scope);
relation statements_assign_use(stmt: auto Statement, target_type: Type, operand: Operand);
relation statements_assign_thead_local_ref(stmt: auto Statement, target_type: Type, def_path: DefPath);
relation statements_assign_repeat(stmt: auto Statement, target_type: Type, operand: Operand, count: u64);
relation statements_assign_ref(stmt: auto Statement, target_type: Type, source_type: Type, kind: BorrowKind);
relation statements_assign_address(stmt: auto Statement, target_type: Type, source_type: Type, mutability: Mutability);
relation statements_assign_len(stmt: auto Statement, target_type: Type, source_type: Type);
relation statements_assign_cast(stmt: auto Statement, target_type: Type, kind: CastKind, operand: Operand, typ: Type);
relation statements_assign_binary_op(stmt: auto Statement, target_type: Type, kind: BinOp, first: Operand, second: Operand);
relation statements_assign_checked_binary_op(stmt: auto Statement, target_type: Type, kind: BinOp, first: Operand, second: Operand);
relation statements_assign_nullary_op(stmt: auto Statement, target_type: Type, kind: NullOp, source_type: Type);
relation statements_assign_unary_op(stmt: auto Statement, target_type: Type, kind: UnOp, operand: Operand);
relation statements_assign_discriminant(stmt: auto Statement, target_type: Type, source_type: Type);
relation statements_assign_aggregate(stmt: auto Statement, target_type: Type, kind: AggregateKind);
relation statements_assign_aggregate_operands(stmt: Statement, index: OperandIndex, operand: Operand);
relation statements_assign_shallow_init_box(stmt: auto Statement, operand: Operand, typ: Type);
relation statements_assign_copy_for_deref(stmt: auto Statement, place_type: Type);
relation statements_inline_asm_inputs(stmt: Statement, operand: Operand);
relation statements_inline_asm_outputs(stmt: Statement, typ: Type);
relation operands(operand: auto Operand, kind: OperandKind, typ: Type);
/// Block terminators. Eeach block has exactly one terminator.
relation terminators(block: BasicBlock, kind: TerminatorKind, scope: Scope);
relation terminators_goto(block: BasicBlock, target: BasicBlock);
relation terminators_switch_int(block: BasicBlock, discriminant: Operand);
relation terminators_switch_int_targets(block: BasicBlock, condition_value: u128, target: BasicBlock);
relation terminators_drop(block: BasicBlock, location: Type, target: BasicBlock);
relation terminators_drop_and_replace(block: BasicBlock, location: Type, value: Operand, target: BasicBlock, unwind: BasicBlock);
relation terminators_call(block: BasicBlock, call: auto FunctionCall, func: Operand, unsafety: Safety, abi: Abi, return_ty: Type, destination: BasicBlock, span: Span);
relation terminators_call_arg(call: FunctionCall, index: CallArgIndex, arg: Operand);
/// The called function or trait method.
relation terminators_call_const_target(call: FunctionCall, def_path: DefPath);
relation terminators_call_const_target_desc(call: FunctionCall, target: InternedString, function_generics: InternedString, type_generics: InternedString);
/// The self argument of the called method.
relation terminators_call_const_target_self(call: FunctionCall, typ: Type);
/// For calls originating from a macro, the path of the top macro in the backtrace that's from a different crate than the call site.
relation terminators_call_macro_backtrace(call: FunctionCall, macro_path: InternedString);
relation terminators_assert(block: BasicBlock, cond: Operand, expected: bool, target: BasicBlock);
relation terminators_yield(block: BasicBlock, value: Operand, resume: BasicBlock, drop: BasicBlock);
relation terminators_false_edges(block: BasicBlock, real_target: BasicBlock, imaginary_target: BasicBlock);
relation terminators_false_unwind(block: BasicBlock, real_target: BasicBlock);
relation terminators_inline_asm(block: BasicBlock);
/// `cleanup` is defined only if action is `Cleanup`.
relation terminators_unwind_action(block: BasicBlock, action: UnwindAction, cleanup: BasicBlock);